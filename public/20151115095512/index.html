<!DOCTYPE html>
<html>
<head>
<title>教程一：键盘鼠标模拟</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<h2 id="-">教程一：键盘鼠标模拟</h2>
<p>原创 2015年11月15日</p>
<blockquote>
<p>本教程面向有C\C++基础的人，最好还要懂一些Windows编程知识<br>代码一律用Visual Studio 2013编译，如果你还在用VC6请趁早丢掉它...<br>写这个教程只是为了让玩家更好地体验所爱的单机游戏，顺便学到些逆向知识，我不会用网络游戏做示范，请自重</p>
</blockquote>
<p>先从最简单的模拟操作讲起<br>模拟键盘鼠标有很多方法，我大体分为消息模拟、API模拟、驱动模拟<br>对于网页的话还可以用JavaScript模拟，虽然这不在本教程范围</p>
<h3 id="-">消息模拟</h3>
<p>学习Windows编程都知道Windows程序会响应窗口消息，那么我们自己发个消息过去程序就会认为是人在操作而响应了<br><strong>看看要用到的API</strong></p>
<pre><code>// 发送消息到指定窗口，不用等待消息处理就返回，参数和窗口过程里的一样  
BOOL WINAPI PostMessage(  
  _In_opt_ HWND   hWnd,  
  _In_     UINT   Msg,  
  _In_     WPARAM wParam,  
  _In_     LPARAM lParam  
);  
// 获取窗口句柄，参数是窗口类名和窗口标题，其中一个可以传入NULL表示通配  
HWND FindWindow(   
  LPCTSTR lpClassName,   
  LPCTSTR lpWindowName   
);  
// 用来获取子窗口句柄  
HWND WINAPI FindWindowEx(  
  _In_opt_ HWND    hwndParent,  
  _In_opt_ HWND    hwndChildAfter,  
  _In_opt_ LPCTSTR lpszClass,  
  _In_opt_ LPCTSTR lpszWindow  
);  
</code></pre><p><strong>以记事本为例子</strong><br>首先要知道记事本的窗口类名<br>打开记事本，打开VS2013，在工具里找到spy++<br><img src="./1.jpg" alt="图片1"><br>在工具条找到查找窗口，把查找程序工具拖到记事本窗口，得到了记事本窗口的类名&quot;Notepad&quot;<br><img src="./2.jpg" alt="图片2"><br>同理可以知道编辑框的类名是Edit<br>我们写个程序模拟在编辑框按下A健</p>
<pre><code>HWND notepadWnd = FindWindow(_T(&quot;Notepad&quot;), NULL); // 记事本窗口句柄  
if (notepadWnd == NULL)  
{  
    printf(&quot;没有找到记事本窗口\n&quot;);  
    return 0;  
}  
HWND editWnd = FindWindowEx(notepadWnd, NULL, _T(&quot;Edit&quot;), NULL); // 编辑框窗口句柄  

const BYTE vk = &#39;A&#39;; // 虚拟键码  
//UINT scanCode = MapVirtualKey(vk, MAPVK_VK_TO_VSC); // 扫描码  
PostMessage(editWnd, WM_KEYDOWN, vk, 1 /*| scanCode &lt;&lt; 16*/);  
Sleep(100);  
PostMessage(editWnd, WM_KEYUP, vk, 1 /*| scanCode &lt;&lt; 16*/ | 1 &lt;&lt; 30 | 1 &lt;&lt; 31); 
</code></pre><p>运行程序，看看记事本里是不是多了个a<br><strong>再写个程序模拟点击鼠标右键</strong><br>用到的新API</p>
<pre><code>// 取坐标处窗口句柄  
HWND WINAPI WindowFromPoint(  
  _In_ POINT Point  
);  
// 取鼠标坐标  
BOOL WINAPI GetCursorPos(  
  _Out_ LPPOINT lpPoint  
);  
// 把屏幕坐标转为相对于窗口客户区的坐标  
BOOL ScreenToClient(  
  _In_ HWND    hWnd,  
       LPPOINT lpPoint  
); 
</code></pre><p>模拟鼠标右键点击的程序</p>
<pre><code>Sleep(3000); // 等待3秒把鼠标移到指定窗口  

POINT pos; // 鼠标坐标  
GetCursorPos(&amp;pos);  
HWND wnd = WindowFromPoint(pos); // 鼠标指向的窗口的句柄  
ScreenToClient(wnd, &amp;pos); // 把pos转成相对于窗口客户区的坐标  
LPARAM lParam = MAKELPARAM(pos.x, pos.y);  

PostMessage(wnd, WM_RBUTTONDOWN, 0, lParam);  
Sleep(100);  
PostMessage(wnd, WM_RBUTTONUP, 0, lParam);
</code></pre><p>运行后把鼠标移到记事本，会弹出菜单<br>发送消息模拟输入的方法好处是就算窗口最小化了也可以模拟，但是缺点是不是所有程序都会处理窗口消息，比如大部分游戏是用DInput输入的</p>
<h3 id="api-">API模拟</h3>
<p>API模拟就是用Windows提供的API模拟输入，比如keybd_event、mouse_event、SendInput，但是微软建议用SendInput代替另外两个，那我就只讲SendInput怎么用了</p>
<p><strong>用到的API</strong></p>
<pre><code>UINT WINAPI SendInput(  
  _In_ UINT    nInputs,  
  _In_ LPINPUT pInputs,  
  _In_ int     cbSize  
);  

typedef struct tagINPUT {  
  DWORD type;  
  union {  
    MOUSEINPUT    mi;  
    KEYBDINPUT    ki;  
    HARDWAREINPUT hi;  
  };  
} INPUT, *PINPUT;
</code></pre><p>这个API可以模拟键盘按下、鼠标移动、鼠标点击等事件，参数是INPUT结构的数量、INPUT数组的指针、INPUT结构的大小<br>INPUT中type取值为INPUT_MOUSE、INPUT_KEYBOARD、INPUT_HARDWARE，分别表示使用mi、ki、hi结构<br>详细说明请看MSDN：<br><a href="https://msdn.microsoft.com/zh-cn/office/ms646273(v=vs.100)">MOUSEINPUT</a><br><a href="https://msdn.microsoft.com/zh-cn/office/ms646271(v=vs.100)">KEYBDINPUT</a></p>
<p><strong>模拟鼠标移动到屏幕中间点击右键</strong></p>
<pre><code>INPUT input[3];  
ZeroMemory(&amp;input, sizeof(input));  
// 鼠标移动到屏幕中间，也可以用SetCursorPos(x, y)  
input[0].type = INPUT_MOUSE;  
input[0].mi.dx = 65535 / 2; // 坐标取值范围是0-65535  
input[0].mi.dy = 65535 / 2;  
input[0].mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;  
// 点击鼠标右键  
input[1].type = INPUT_MOUSE;  
input[1].mi.dwFlags = MOUSEEVENTF_RIGHTDOWN;  
input[2].type = INPUT_MOUSE;  
input[2].mi.dwFlags = MOUSEEVENTF_RIGHTUP;  

SendInput(_countof(input), input, sizeof(INPUT));
</code></pre><p><strong>模拟按下A键</strong></p>
<pre><code>INPUT input[2];  
ZeroMemory(&amp;input, sizeof(input));  
input[0].type = INPUT_KEYBOARD;  
input[0].ki.wVk = &#39;A&#39;;  
// 也可以不加这句但是对DInput输入的程序会没用  
input[0].ki.wScan = MapVirtualKey(input[0].ki.wVk, MAPVK_VK_TO_VSC);  
input[1].type = INPUT_KEYBOARD;  
input[1].ki.wVk = input[0].ki.wVk;  
input[1].ki.wScan = input[0].ki.wScan;  
input[1].ki.dwFlags = KEYEVENTF_KEYUP;  

SendInput(_countof(input), input, sizeof(INPUT));
</code></pre><p><strong>来个高级点的例子：东方花映冢Z键连打</strong><br>东方花映冢里想发轻弹幕就要不停按Z键，这样很费劲，所以我想实现按住C键就能自动发轻弹幕的功能（就像妖精大战争那样）<br>这个程序用到了MFC，看不懂的话建议学一下MFC编程</p>
<pre><code>// 开启  
void CC2ZDlg::OnBnClickedButton1()  
{  
    m_enableButton.EnableWindow(FALSE);  
    m_disableButton.EnableWindow(TRUE);  
    SetTimer(1, 200, timerProc); // 每0.2s检测C键是否按下，并模拟Z键  
}  

// 关闭  
void CC2ZDlg::OnBnClickedButton2()  
{  
    m_enableButton.EnableWindow(TRUE);  
    m_disableButton.EnableWindow(FALSE);  
    KillTimer(1);  
}  

//定时模拟按下Z  
void CALLBACK CC2ZDlg::timerProc(HWND hWnd, UINT nMsg, UINT nTimerid, DWORD dwTime)  
{  
    if ((GetKeyState(&#39;C&#39;) &amp; (1 &lt;&lt; 15)) != 0) // C键按下  
    {  
        INPUT input;  
        ZeroMemory(&amp;input, sizeof(input));  
        input.type = INPUT_KEYBOARD;  
        input.ki.wVk = &#39;Z&#39;;  
        input.ki.wScan = MapVirtualKey(input.ki.wVk, MAPVK_VK_TO_VSC);  
        SendInput(1, &amp;input, sizeof(INPUT)); // 按下Z键  
        Sleep(100); // 可能东方是在处理逻辑时检测一下Z键是否按下才发弹幕，如果这时Z键刚好弹起就没有反应，所以要延迟一下  
        input.ki.dwFlags = KEYEVENTF_KEYUP;  
        SendInput(1, &amp;input, sizeof(INPUT)); // 弹起Z键  
    }  
}
</code></pre><p><a href="https://github.com/xfgryujk/CheatingTutorial/tree/master/C2Z">完整源码</a></p>
<p>这样就可以模拟大部分游戏的输入了，但是有些游戏会有保护，这样就要用到驱动模拟</p>
<h3 id="-">驱动模拟</h3>
<p>驱动模拟就是自己写驱动程序，在系统内核里面操作I/O端口，给连接键盘的集成电路（一般是8042芯片）发送指令，让它产生一个按下按键的信息，这样你的模拟输入对于所有程序来说就是从一个真实的设备发出的，而且可以绕过很多保护<br>（需要操作I/O端口的话可以学习一下<strong>WinIo库</strong>）<br>然而我并不会写这种驱动<em>(:з」∠)</em>，而且x64系统中加载驱动需要有可信任的数字签名，否则会比较麻烦，而且还要知道8042芯片相关的底层知识...<br>所以我找了个别人写的库实现驱动模拟<br><a href="http://www.oblita.com/interception">Interception官网</a><br><a href="https://github.com/oblitum/Interception">Interception API的Git库</a></p>
<p>它的驱动有数字签名而且在XP到win10的平台上都测试过了<br>它还可以拦截并修改输入（包括CTRL+ALT+DELETE），不过这里我只讲模拟输入所以自己研究吧...<br>（好像它的模拟输入也不是操作端口而是内核版的SendInput？）<br><strong>安装方法</strong><br>（可以去<a href="http://pan.baidu.com/s/1hq6lTPU">我的网盘</a>）下载Interception.zip，解压后运行install-interception.exe<br>环境搭建：如果目标系统是64位的要先在配置管理器里加入x64配置</p>
<p><img src="./3.jpg" alt="图片3"><br>在你的项目属性里找到VC++目录，包含目录加上Interception\library，库目录根据目标系统是64位还是32位加上library\x64或library\x86<br>找到链接器-输入，附加依赖项加上interception.lib<br>然后把library\x64或library\x86里的interception.dll放到你的程序同目录下<br>最后在你的源码里<code>#include &lt;interception.h&gt;</code><br><strong>模拟鼠标移动到屏幕中间点击右键</strong></p>
<pre><code>InterceptionContext context = interception_create_context();  

InterceptionMouseStroke mouseStroke[3];  
ZeroMemory(mouseStroke, sizeof(mouseStroke));  
// 鼠标移动到屏幕中间  
mouseStroke[0].flags = INTERCEPTION_MOUSE_MOVE_ABSOLUTE;  
mouseStroke[0].x = 65535 / 2; // 坐标取值范围是0-65535  
mouseStroke[0].y = 65535 / 2;  
// 点击鼠标右键  
mouseStroke[1].state = INTERCEPTION_MOUSE_RIGHT_BUTTON_DOWN;  
mouseStroke[2].state = INTERCEPTION_MOUSE_RIGHT_BUTTON_UP;  
interception_send(context, INTERCEPTION_MOUSE(0), (InterceptionStroke*)mouseStroke, _countof(mouseStroke));  

interception_destroy_context(context);
</code></pre><p><strong>模拟按下A键</strong></p>
<pre><code>InterceptionContext context = interception_create_context();  

InterceptionKeyStroke keyStroke[2];  
ZeroMemory(keyStroke, sizeof(keyStroke));  
keyStroke[0].code = MapVirtualKey(&#39;A&#39;, MAPVK_VK_TO_VSC);  
keyStroke[0].state = INTERCEPTION_KEY_DOWN;  
keyStroke[1].code = keyStroke[0].code;  
keyStroke[1].state = INTERCEPTION_KEY_UP;  
interception_send(context, INTERCEPTION_KEYBOARD(0), (InterceptionStroke*)keyStroke, _countof(keyStroke));  

interception_destroy_context(context);
</code></pre><p>驱动模拟很强大，不过比较麻烦，一般也用不到<em>(:з」∠)</em></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
