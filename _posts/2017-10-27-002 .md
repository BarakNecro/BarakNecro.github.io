---
layout:     post
title:      "关于内存的分段与分页机制"
subtitle:   ""
date:       2017-10-27 14:44:00
author:     "SinZheng"
header-img: "img/post-bg-unix-linux.jpg"
catalog: true
tags:
    - 内存
    - 分页
---
>这是一篇转载的博文，介绍关于内存的分段与分页机制，其中有看雪的文章也有互联网的文章，以及个人一点点肤浅的理解。

以下内容多数源于其他博文，末尾部分自己总结，真诚感谢原文作者。

## 分段机制

在8086时期，寄存器是16位，无法存放20位的物理地址，为了解决这问题，人们提出了分段机制，分段机制就是将内存分段，每段大小**64kb**（正好由16位表示）,在段寄存器中放入段基址，然后+上段偏移量就成了物理地址。

## 分页机制

Windows 2000 使用基于分页机制的虚拟内存。每个进程有4GB的虚拟地址空间。基于分页机制，这4GB地址空间的一些部分被映射了物理内存，一些部分映射硬盘上的交换文件，一些部分什么也没有映射。程序中使用的都是4GB地址空间中的虚拟地址。而访问物理内存，需要使用物理地址。

下面我们看看什么是物理地址，什么是虚拟地址。

### 物理地址

物理地址 (physical address): 放在寻址总线上的地址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个地址每位的值就将相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的。

### 虚拟地址

虚拟地址 (virtual address): 4G虚拟地址空间中的地址，程序中使用的都是虚拟地址。

![图片02](./02.jpg)

由图可知, 虚拟地址的前10位用来定位页目录项, 中间10位用来定位页表项, 最后12位得到具体物理地址的偏移.

### 分页标志位

如果CPU寄存器中的分页标志位被设置，那么执行内存操作的机器指令时，CPU会自动根据页目录和页表中的信息，把虚拟地址转换成物理地址，完成该指令。比如 mov eax,004227b8h ，这是把地址004227b8h处的值赋给寄存器的汇编代码，004227b8这个地址就是虚拟址。CPU在执行这行代码时，发现寄存器中的分页标志位已经被设定，就自动完成虚拟地址到物理地址的转换，使用物理地址取出值，完成指令。对于Intel CPU 来说，分页标志位是寄存器CR0的第31位，为1表示使用分页，为0表示不使用分页。对于初始化之后的 Win2k 我们观察 CR0 ，发现第31位为1。表明Win2k是使用分页的。

### 页的长度

使用了分页机制之后，4G的地址空间被分成了固定大小的页，每一页或者被映射到物理内存，或者被映射到硬盘上的交换文件中，或者没有映射任何东西。对于一般程序来说，4G的地址空间，只有一小部分映射了物理内存，大片大片的部分是没有映射任何东西。物理内存也被分页，来映射地址空间。对于**32bit的Win2k，页的大小是4K字节**。CPU用来把虚拟地址转换成物理地址的信息存放在叫做页目录和页表的结构里。

### R0与R3内存
4G地址空间中低2G，0x00000000-0x7FFFFFFF 是用户地址空间，4G地址空间中高2G，0x80000000-0xFFFFFFFF 是系统地址空间。访问系统地址空间需要程序有ring0的权限。

## 总结部分

内存地址的转换主要通过一个称为页表目录的特殊表来完成. Intel x86 CPU将页表目录的指针存储在特殊寄存器CR3中. 该寄存器指向一个包含1024个32位值的数组, 称为页目录. 每个数组元素称为页目录项, 它指定了页表在物理内存中的基地址, 还通过状态位指示该页表当前是否存在于内存中. 从页表中可以获得实际的物理地址.

![图片01](./01.jpg)

### 页目录

页目录，一个页目录大小为4K字节，放在一个物理页中。由1024个4字节的页目录项组成。页目录项的大小为4个字节(32bit)，所以一个页目录中有1024个页目录项。页目录中的每一项的内容（每项4个字节）高20bit用来放一个页表（页表放在一个物理页中）的物理地址，低12bit放着一些标志。对于x86系统，页目录的物理地址放在CPU的CR3寄存器中。

下面我们看下页目录项的地址组成：
！[图片03](./03.jpg)

当访问页目录项时, 要检查U位(第2位), 若U位为0, 则意味着正在处理的页表只能用于内核.
还要检查W位(第1位), 若W位为0, 则内存是只读的.
页目录项指向整个页表, 即整个页面集合, 因此, 页目录项中的设置应用于整个内存页范围.

### 页表

页表，一个页表的大小为4K字节，放在一个物理页中。由1024个4字节的页表项组成。页表项的大小为4个字节(32bit)，所以一个页表中有1024个页表项。页表中的每一项的内容（每项4个字节,32bit）高20bit用来放一个物理页的物理地址，低12bit放着一些标志。（由于2的20次方乘以2的12次方（页大小）就等于了进程的4G地址空间）

下面来看下页表项：
![图片04](./04.jpg)

当访问页表项时, 仍然首先要检查U位(第2位), 若U位为0, 则只有内核模式的程序才能够访问该内存页.
还要检查W位(第1位), 以判断读写访问权限.
最后还要判断P位(第0位), 若它设置为0, 则当前内存页被换出在磁盘上. 若它设置为1, 则内存是常驻, 并且当前是可用的.
在将内存页换出后, 内存管理器在成功访问它之前必须将该页换入内存.

### 物理页

物理内存分页，一个物理页的大小为4K字节，第0个物理页从物理地址 0x00000000 处开始。由于页的大小为4KB，就是0x1000字节，所以第1页从物理地址 0x00001000 处开始。第2页从物理地址 0x00002000 处开始。可以看到由于页的大小是4KB，所以只需要32bit的地址中高20bit来寻址物理页。

### 虚拟地址转换成物理地址过程

CPU把虚拟地址转换成物理地址：
一个虚拟地址，大小4个字节(32bit)，包含着找到物理地址的信息，分为3个部分：

0. 第22位到第31位这10位（最高10位）是页目录中的索引
1. 第12位到第21位这10位是页表中的索引
2. 第0位到第11位这12位（低12位）是页内偏移

对于一个要转换成物理地址的虚拟地址:

0. CPU首先根据CR3中的值，找到页目录所在的物理页。

1. 然后根据虚拟地址的第22位到第31位这10位（最高的10bit)的值作为索引，找到相应的页目录项(PDE,page directory entry),页目录项中有这个虚拟地址所对应页表的物理地址。

2. 有了页表的物理地址，根据虚拟地址的第12位到第21位这10位的值作为索引，找到该页表中相应的页表项(PTE,page table entry),页表项中就有这个虚拟地址所对应物理页的物理地址。

3. 最后用虚拟地址的最低12位，也就是页内偏移，加上这个物理页的物理地址，就得到了该虚拟地址所对应的物理地址。

一个页目录有1024项，虚拟地址最高的10bit刚好可以索引1024项（2的10次方等于1024）。一个页表也有1024项，虚拟地址中间部分的10bit，刚好索引1024项。虚拟地址最低的12bit（2的12次方等于4096），作为页内偏移，刚好可以索引4KB，也就是一个物理页中的每个字节。

32bit的一个指针，可以寻址范围0x00000000-0xFFFFFFFF,4GB大小。

也就是说一个32bit的指针可以寻址整个4GB地址空间的每一个字节。

一个**页表项负责4K的地址空间和物理内存的映射**，一个页表1024项，也就是负责1024*4k=4M的地址空间的映射。

一个页目录项，对应一个页表。一个页目录有1024项，也就对应着1024个页表，**每个页表负责4M地址空间的映射**。

1024个*页目录项负责1024*4M=4G的地址空间映射，即**每个页目录负责4G地址空间的映射**。

### 进程空间的私有性

还有最后一个问题就是, 系统上的大多数可执行程序的其实地址都是0x00400000. 多个进程如何能使用同一个虚拟地址, 而不会在物理内存中发生冲突?

那是因为系统上的每个进程都维护一个独立的页目录, 都拥有自己私有的CR3寄存器的值.

当线程发生切换时, 旧线程的状态会被保存起来. 若当前调度运行的线程不属于刚才的进程, 则当前进程的页目录地址会被加载到CR3寄存器中. 页目录地址可以在进程的KPROCESS结构中找到.

**一个进程有一个页目录。**所以以页为单位，页目录和页表可以保证4G的地址空间中的每页和物理内存的映射。